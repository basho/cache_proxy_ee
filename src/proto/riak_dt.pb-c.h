/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: src/riak_dt.proto */

#ifndef PROTOBUF_C_src_2friak_5fdt_2eproto__INCLUDED
#define PROTOBUF_C_src_2friak_5fdt_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1000000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1001001 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif


typedef struct _MapField MapField;
typedef struct _MapEntry MapEntry;
typedef struct _DtFetchReq DtFetchReq;
typedef struct _DtValue DtValue;
typedef struct _DtFetchResp DtFetchResp;
typedef struct _CounterOp CounterOp;
typedef struct _SetOp SetOp;
typedef struct _MapUpdate MapUpdate;
typedef struct _MapOp MapOp;
typedef struct _DtOp DtOp;
typedef struct _DtUpdateReq DtUpdateReq;
typedef struct _DtUpdateResp DtUpdateResp;


/* --- enums --- */

/*
 * The types that can be stored in a map are limited to counters,
 * sets, registers, flags, and maps.
 */
typedef enum _MapField__MapFieldType {
  MAP_FIELD__MAP_FIELD_TYPE__COUNTER = 1,
  MAP_FIELD__MAP_FIELD_TYPE__SET = 2,
  MAP_FIELD__MAP_FIELD_TYPE__REGISTER = 3,
  MAP_FIELD__MAP_FIELD_TYPE__FLAG = 4,
  MAP_FIELD__MAP_FIELD_TYPE__MAP = 5
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(MAP_FIELD__MAP_FIELD_TYPE)
} MapField__MapFieldType;
typedef enum _DtFetchResp__DataType {
  DT_FETCH_RESP__DATA_TYPE__COUNTER = 1,
  DT_FETCH_RESP__DATA_TYPE__SET = 2,
  DT_FETCH_RESP__DATA_TYPE__MAP = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(DT_FETCH_RESP__DATA_TYPE)
} DtFetchResp__DataType;
/*
 * Flags only exist inside Maps and can only be enabled or
 * disabled, and there are no arguments to the operations.
 */
typedef enum _MapUpdate__FlagOp {
  MAP_UPDATE__FLAG_OP__ENABLE = 1,
  MAP_UPDATE__FLAG_OP__DISABLE = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(MAP_UPDATE__FLAG_OP)
} MapUpdate__FlagOp;

/* --- messages --- */

/*
 * Field names in maps are composed of a binary identifier and a type.
 * This is so that two clients can create fields with the same name
 * but different types, and they converge independently.
 */
struct  _MapField
{
  ProtobufCMessage base;
  ProtobufCBinaryData name;
  MapField__MapFieldType type;
};
#define MAP_FIELD__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&map_field__descriptor) \
    , {0,NULL}, 0 }


/*
 * An entry in a map is a pair of a field-name and value. The type
 * defined in the field determines which value type is expected.
 */
struct  _MapEntry
{
  ProtobufCMessage base;
  MapField *field;
  protobuf_c_boolean has_counter_value;
  int64_t counter_value;
  size_t n_set_value;
  ProtobufCBinaryData *set_value;
  protobuf_c_boolean has_register_value;
  ProtobufCBinaryData register_value;
  protobuf_c_boolean has_flag_value;
  protobuf_c_boolean flag_value;
  size_t n_map_value;
  MapEntry **map_value;
};
#define MAP_ENTRY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&map_entry__descriptor) \
    , NULL, 0,0, 0,NULL, 0,{0,NULL}, 0,0, 0,NULL }


/*
 * The equivalent of KV's "RpbGetReq", results in a DtFetchResp. The
 * request-time options are limited to ones that are relevant to
 * structured data-types.
 */
struct  _DtFetchReq
{
  ProtobufCMessage base;
  /*
   * The identifier: bucket, key and bucket-type
   */
  ProtobufCBinaryData bucket;
  ProtobufCBinaryData key;
  ProtobufCBinaryData type;
  /*
   * Request options
   */
  protobuf_c_boolean has_r;
  uint32_t r;
  protobuf_c_boolean has_pr;
  uint32_t pr;
  protobuf_c_boolean has_basic_quorum;
  protobuf_c_boolean basic_quorum;
  protobuf_c_boolean has_notfound_ok;
  protobuf_c_boolean notfound_ok;
  protobuf_c_boolean has_timeout;
  uint32_t timeout;
  /*
   * Experimental, may change/disappear
   */
  protobuf_c_boolean has_sloppy_quorum;
  protobuf_c_boolean sloppy_quorum;
  /*
   * Experimental, may change/disappear
   */
  protobuf_c_boolean has_n_val;
  uint32_t n_val;
  /*
   * For read-only requests or context-free operations, you can set
   * this to false to reduce the size of the response payload.
   */
  protobuf_c_boolean has_include_context;
  protobuf_c_boolean include_context;
};
#define DT_FETCH_REQ__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&dt_fetch_req__descriptor) \
    , {0,NULL}, {0,NULL}, {0,NULL}, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,1 }


/*
 * The value of the fetched data type. If present in the response,
 * then empty values (sets, maps) should be treated as such.
 */
struct  _DtValue
{
  ProtobufCMessage base;
  protobuf_c_boolean has_counter_value;
  int64_t counter_value;
  size_t n_set_value;
  ProtobufCBinaryData *set_value;
  size_t n_map_value;
  MapEntry **map_value;
};
#define DT_VALUE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&dt_value__descriptor) \
    , 0,0, 0,NULL, 0,NULL }


/*
 * The response to a "Fetch" request. If the `include_context` option
 * is specified, an opaque "context" value will be returned along with
 * the user-friendly data. When sending an "Update" request, the
 * client should send this context as well, similar to how one would
 * send a vclock for KV updates. The `type` field indicates which
 * value type to expect. When the `value` field is missing from the
 * message, the client should interpret it as a "not found".
 */
struct  _DtFetchResp
{
  ProtobufCMessage base;
  protobuf_c_boolean has_context;
  ProtobufCBinaryData context;
  DtFetchResp__DataType type;
  DtValue *value;
};
#define DT_FETCH_RESP__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&dt_fetch_resp__descriptor) \
    , 0,{0,NULL}, 0, NULL }


/*
 * An operation to update a Counter, either on its own or inside a
 * Map. The `increment` field can be positive or negative. When absent,
 * the meaning is an increment by 1.
 */
struct  _CounterOp
{
  ProtobufCMessage base;
  protobuf_c_boolean has_increment;
  int64_t increment;
};
#define COUNTER_OP__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&counter_op__descriptor) \
    , 0,0 }


/*
 * An operation to update a Set, either on its own or inside a Map.
 * Set members are opaque binary values, you can only add or remove
 * them from a Set.
 */
struct  _SetOp
{
  ProtobufCMessage base;
  size_t n_adds;
  ProtobufCBinaryData *adds;
  size_t n_removes;
  ProtobufCBinaryData *removes;
};
#define SET_OP__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&set_op__descriptor) \
    , 0,NULL, 0,NULL }


/*
 * An operation to be applied to a value stored in a Map -- the
 * contents of an UPDATE operation. The operation field that is
 * present depends on the type of the field to which it is applied.
 */
struct  _MapUpdate
{
  ProtobufCMessage base;
  MapField *field;
  CounterOp *counter_op;
  SetOp *set_op;
  /*
   * There is only one operation on a register, which is to set its
   * value, therefore the "operation" is the new value.
   */
  protobuf_c_boolean has_register_op;
  ProtobufCBinaryData register_op;
  protobuf_c_boolean has_flag_op;
  MapUpdate__FlagOp flag_op;
  MapOp *map_op;
};
#define MAP_UPDATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&map_update__descriptor) \
    , NULL, NULL, NULL, 0,{0,NULL}, 0,0, NULL }


/*
 * An operation to update a Map. All operations apply to individual
 * fields in the Map.
 */
struct  _MapOp
{
  ProtobufCMessage base;
  /*
   *  REMOVE removes a field and value from the Map.
   * UPDATE applies type-specific
   * operations to the values stored in the Map.
   */
  size_t n_removes;
  MapField **removes;
  size_t n_updates;
  MapUpdate **updates;
};
#define MAP_OP__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&map_op__descriptor) \
    , 0,NULL, 0,NULL }


/*
 * A "union" type for update operations. The included operation
 * depends on the datatype being updated.
 */
struct  _DtOp
{
  ProtobufCMessage base;
  CounterOp *counter_op;
  SetOp *set_op;
  MapOp *map_op;
};
#define DT_OP__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&dt_op__descriptor) \
    , NULL, NULL, NULL }


/*
 * The equivalent of KV's "RpbPutReq", results in an empty response or
 * "DtUpdateResp" if `return_body` is specified, or the key is
 * assigned by the server. The request-time options are limited to
 * ones that are relevant to structured data-types.
 */
struct  _DtUpdateReq
{
  ProtobufCMessage base;
  /*
   * The identifier
   */
  ProtobufCBinaryData bucket;
  /*
   * missing key results in server-assigned key, like KV
   */
  protobuf_c_boolean has_key;
  ProtobufCBinaryData key;
  /*
   * bucket type, not data-type (but the data-type is constrained per bucket-type)
   */
  ProtobufCBinaryData type;
  /*
   * Opaque update-context
   */
  protobuf_c_boolean has_context;
  ProtobufCBinaryData context;
  /*
   * The operations
   */
  DtOp *op;
  /*
   * Request options
   */
  protobuf_c_boolean has_w;
  uint32_t w;
  protobuf_c_boolean has_dw;
  uint32_t dw;
  protobuf_c_boolean has_pw;
  uint32_t pw;
  protobuf_c_boolean has_return_body;
  protobuf_c_boolean return_body;
  protobuf_c_boolean has_timeout;
  uint32_t timeout;
  /*
   * Experimental, may change/disappear
   */
  protobuf_c_boolean has_sloppy_quorum;
  protobuf_c_boolean sloppy_quorum;
  /*
   * Experimental, may change/disappear
   */
  protobuf_c_boolean has_n_val;
  uint32_t n_val;
  /*
   * When return_body is true, should the context be returned too?
   */
  protobuf_c_boolean has_include_context;
  protobuf_c_boolean include_context;
};
#define DT_UPDATE_REQ__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&dt_update_req__descriptor) \
    , {0,NULL}, 0,{0,NULL}, {0,NULL}, 0,{0,NULL}, NULL, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,1 }


/*
 * The equivalent of KV's "RpbPutResp", contains the assigned key if
 * it was assigned by the server, and the resulting value and context
 * if return_body was set.
 */
struct  _DtUpdateResp
{
  ProtobufCMessage base;
  /*
   * The key, if assigned by the server
   */
  protobuf_c_boolean has_key;
  ProtobufCBinaryData key;
  /*
   * The opaque update context and value, if return_body was set.
   */
  protobuf_c_boolean has_context;
  ProtobufCBinaryData context;
  protobuf_c_boolean has_counter_value;
  int64_t counter_value;
  size_t n_set_value;
  ProtobufCBinaryData *set_value;
  size_t n_map_value;
  MapEntry **map_value;
};
#define DT_UPDATE_RESP__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&dt_update_resp__descriptor) \
    , 0,{0,NULL}, 0,{0,NULL}, 0,0, 0,NULL, 0,NULL }


/* MapField methods */
void   map_field__init
                     (MapField         *message);
size_t map_field__get_packed_size
                     (const MapField   *message);
size_t map_field__pack
                     (const MapField   *message,
                      uint8_t             *out);
size_t map_field__pack_to_buffer
                     (const MapField   *message,
                      ProtobufCBuffer     *buffer);
MapField *
       map_field__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   map_field__free_unpacked
                     (MapField *message,
                      ProtobufCAllocator *allocator);
/* MapEntry methods */
void   map_entry__init
                     (MapEntry         *message);
size_t map_entry__get_packed_size
                     (const MapEntry   *message);
size_t map_entry__pack
                     (const MapEntry   *message,
                      uint8_t             *out);
size_t map_entry__pack_to_buffer
                     (const MapEntry   *message,
                      ProtobufCBuffer     *buffer);
MapEntry *
       map_entry__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   map_entry__free_unpacked
                     (MapEntry *message,
                      ProtobufCAllocator *allocator);
/* DtFetchReq methods */
void   dt_fetch_req__init
                     (DtFetchReq         *message);
size_t dt_fetch_req__get_packed_size
                     (const DtFetchReq   *message);
size_t dt_fetch_req__pack
                     (const DtFetchReq   *message,
                      uint8_t             *out);
size_t dt_fetch_req__pack_to_buffer
                     (const DtFetchReq   *message,
                      ProtobufCBuffer     *buffer);
DtFetchReq *
       dt_fetch_req__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   dt_fetch_req__free_unpacked
                     (DtFetchReq *message,
                      ProtobufCAllocator *allocator);
/* DtValue methods */
void   dt_value__init
                     (DtValue         *message);
size_t dt_value__get_packed_size
                     (const DtValue   *message);
size_t dt_value__pack
                     (const DtValue   *message,
                      uint8_t             *out);
size_t dt_value__pack_to_buffer
                     (const DtValue   *message,
                      ProtobufCBuffer     *buffer);
DtValue *
       dt_value__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   dt_value__free_unpacked
                     (DtValue *message,
                      ProtobufCAllocator *allocator);
/* DtFetchResp methods */
void   dt_fetch_resp__init
                     (DtFetchResp         *message);
size_t dt_fetch_resp__get_packed_size
                     (const DtFetchResp   *message);
size_t dt_fetch_resp__pack
                     (const DtFetchResp   *message,
                      uint8_t             *out);
size_t dt_fetch_resp__pack_to_buffer
                     (const DtFetchResp   *message,
                      ProtobufCBuffer     *buffer);
DtFetchResp *
       dt_fetch_resp__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   dt_fetch_resp__free_unpacked
                     (DtFetchResp *message,
                      ProtobufCAllocator *allocator);
/* CounterOp methods */
void   counter_op__init
                     (CounterOp         *message);
size_t counter_op__get_packed_size
                     (const CounterOp   *message);
size_t counter_op__pack
                     (const CounterOp   *message,
                      uint8_t             *out);
size_t counter_op__pack_to_buffer
                     (const CounterOp   *message,
                      ProtobufCBuffer     *buffer);
CounterOp *
       counter_op__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   counter_op__free_unpacked
                     (CounterOp *message,
                      ProtobufCAllocator *allocator);
/* SetOp methods */
void   set_op__init
                     (SetOp         *message);
size_t set_op__get_packed_size
                     (const SetOp   *message);
size_t set_op__pack
                     (const SetOp   *message,
                      uint8_t             *out);
size_t set_op__pack_to_buffer
                     (const SetOp   *message,
                      ProtobufCBuffer     *buffer);
SetOp *
       set_op__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   set_op__free_unpacked
                     (SetOp *message,
                      ProtobufCAllocator *allocator);
/* MapUpdate methods */
void   map_update__init
                     (MapUpdate         *message);
size_t map_update__get_packed_size
                     (const MapUpdate   *message);
size_t map_update__pack
                     (const MapUpdate   *message,
                      uint8_t             *out);
size_t map_update__pack_to_buffer
                     (const MapUpdate   *message,
                      ProtobufCBuffer     *buffer);
MapUpdate *
       map_update__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   map_update__free_unpacked
                     (MapUpdate *message,
                      ProtobufCAllocator *allocator);
/* MapOp methods */
void   map_op__init
                     (MapOp         *message);
size_t map_op__get_packed_size
                     (const MapOp   *message);
size_t map_op__pack
                     (const MapOp   *message,
                      uint8_t             *out);
size_t map_op__pack_to_buffer
                     (const MapOp   *message,
                      ProtobufCBuffer     *buffer);
MapOp *
       map_op__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   map_op__free_unpacked
                     (MapOp *message,
                      ProtobufCAllocator *allocator);
/* DtOp methods */
void   dt_op__init
                     (DtOp         *message);
size_t dt_op__get_packed_size
                     (const DtOp   *message);
size_t dt_op__pack
                     (const DtOp   *message,
                      uint8_t             *out);
size_t dt_op__pack_to_buffer
                     (const DtOp   *message,
                      ProtobufCBuffer     *buffer);
DtOp *
       dt_op__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   dt_op__free_unpacked
                     (DtOp *message,
                      ProtobufCAllocator *allocator);
/* DtUpdateReq methods */
void   dt_update_req__init
                     (DtUpdateReq         *message);
size_t dt_update_req__get_packed_size
                     (const DtUpdateReq   *message);
size_t dt_update_req__pack
                     (const DtUpdateReq   *message,
                      uint8_t             *out);
size_t dt_update_req__pack_to_buffer
                     (const DtUpdateReq   *message,
                      ProtobufCBuffer     *buffer);
DtUpdateReq *
       dt_update_req__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   dt_update_req__free_unpacked
                     (DtUpdateReq *message,
                      ProtobufCAllocator *allocator);
/* DtUpdateResp methods */
void   dt_update_resp__init
                     (DtUpdateResp         *message);
size_t dt_update_resp__get_packed_size
                     (const DtUpdateResp   *message);
size_t dt_update_resp__pack
                     (const DtUpdateResp   *message,
                      uint8_t             *out);
size_t dt_update_resp__pack_to_buffer
                     (const DtUpdateResp   *message,
                      ProtobufCBuffer     *buffer);
DtUpdateResp *
       dt_update_resp__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   dt_update_resp__free_unpacked
                     (DtUpdateResp *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*MapField_Closure)
                 (const MapField *message,
                  void *closure_data);
typedef void (*MapEntry_Closure)
                 (const MapEntry *message,
                  void *closure_data);
typedef void (*DtFetchReq_Closure)
                 (const DtFetchReq *message,
                  void *closure_data);
typedef void (*DtValue_Closure)
                 (const DtValue *message,
                  void *closure_data);
typedef void (*DtFetchResp_Closure)
                 (const DtFetchResp *message,
                  void *closure_data);
typedef void (*CounterOp_Closure)
                 (const CounterOp *message,
                  void *closure_data);
typedef void (*SetOp_Closure)
                 (const SetOp *message,
                  void *closure_data);
typedef void (*MapUpdate_Closure)
                 (const MapUpdate *message,
                  void *closure_data);
typedef void (*MapOp_Closure)
                 (const MapOp *message,
                  void *closure_data);
typedef void (*DtOp_Closure)
                 (const DtOp *message,
                  void *closure_data);
typedef void (*DtUpdateReq_Closure)
                 (const DtUpdateReq *message,
                  void *closure_data);
typedef void (*DtUpdateResp_Closure)
                 (const DtUpdateResp *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor map_field__descriptor;
extern const ProtobufCEnumDescriptor    map_field__map_field_type__descriptor;
extern const ProtobufCMessageDescriptor map_entry__descriptor;
extern const ProtobufCMessageDescriptor dt_fetch_req__descriptor;
extern const ProtobufCMessageDescriptor dt_value__descriptor;
extern const ProtobufCMessageDescriptor dt_fetch_resp__descriptor;
extern const ProtobufCEnumDescriptor    dt_fetch_resp__data_type__descriptor;
extern const ProtobufCMessageDescriptor counter_op__descriptor;
extern const ProtobufCMessageDescriptor set_op__descriptor;
extern const ProtobufCMessageDescriptor map_update__descriptor;
extern const ProtobufCEnumDescriptor    map_update__flag_op__descriptor;
extern const ProtobufCMessageDescriptor map_op__descriptor;
extern const ProtobufCMessageDescriptor dt_op__descriptor;
extern const ProtobufCMessageDescriptor dt_update_req__descriptor;
extern const ProtobufCMessageDescriptor dt_update_resp__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_src_2friak_5fdt_2eproto__INCLUDED */
